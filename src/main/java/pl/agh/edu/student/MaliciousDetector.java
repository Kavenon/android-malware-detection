package pl.agh.edu.student;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.*;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import weka.classifiers.functions.LibSVM;

import org.datavec.api.formats.input.impl.LibSvmInputFormat;
import org.deeplearning4j.models.paragraphvectors.ParagraphVectors;
import org.deeplearning4j.models.word2vec.VocabWord;
import org.deeplearning4j.models.word2vec.wordstore.inmemory.AbstractCache;
import org.deeplearning4j.text.tokenization.tokenizerfactory.DefaultTokenizerFactory;
import org.deeplearning4j.text.tokenization.tokenizerfactory.TokenizerFactory;
import weka.classifiers.Classifier;
import weka.classifiers.bayes.NaiveBayes;
import weka.classifiers.functions.SimpleLinearRegression;
import weka.classifiers.lazy.IBk;
import weka.classifiers.trees.J48;
import weka.core.*;

public class MaliciousDetector {

    LinkedList<SyscallLogRegistry> bbc_c_c1;
    LinkedList<SyscallLogRegistry> bbc_c_h1;
    LinkedList<SyscallLogRegistry> bbc_c_h2;
    //LinkedList<SyscallLogRegistry> bbc_m_c1;
    LinkedList<SyscallLogRegistry> bbc_m_h1;
    LinkedList<SyscallLogRegistry> bbc_m_h2;
    LinkedList<SyscallLogRegistry> calc_c_c1;
    LinkedList<SyscallLogRegistry> calc_c_h1;
    LinkedList<SyscallLogRegistry> calc_c_h2;
    //LinkedList<SyscallLogRegistry> calc_m_c1;
    LinkedList<SyscallLogRegistry> calc_m_h1;
    LinkedList<SyscallLogRegistry> calc_m_h2;
    LinkedList<SyscallLogRegistry> cana_c_c1;
    LinkedList<SyscallLogRegistry> cana_c_h1;
    LinkedList<SyscallLogRegistry> cana_c_h2;
    //LinkedList<SyscallLogRegistry> cana_m_c1;
    LinkedList<SyscallLogRegistry> cana_m_h1;
    LinkedList<SyscallLogRegistry> cana_m_h2;

    ArrayList<LinkedList<SyscallLogRegistry>> testingFiles = new ArrayList();
    public boolean prepareTestingSet() {
        bbc_c_h1 = getSyscalls("bbc-clear-hot-1.log", LogStatus.GOOD, 0);
        //bbc_m_c1 = getSyscalls("bbc-malware-cold-1.log", LogStatus.MALICIOUS, 0);
        bbc_m_h1 = getSyscalls("bbc-malware-hot-1.log", LogStatus.MALICIOUS, 0);
        //calc_c_c1 = getSyscalls("calc-clear-cold-1.log", LogStatus.GOOD, 0);
        calc_c_h2 = getSyscalls("calc-clear-hot-2.log", LogStatus.GOOD, 0);
        calc_m_h1 = getSyscalls("calc-malware-hot-1.log", LogStatus.MALICIOUS, 0);
        cana_c_h1 = getSyscalls("canary-clear-hot-1.log", LogStatus.GOOD, 0);
        //cana_m_c1 = getSyscalls("canary-malware-cold-1.log", LogStatus.MALICIOUS, 0);

        cana_m_h1 = getSyscalls("canary-malware-hot-1.log", LogStatus.MALICIOUS, 0);

        testingFiles.add(bbc_c_h1);
        //testingFiles.add(bbc_m_c1);
        testingFiles.add(bbc_m_h1);
        //testingFiles.add(calc_c_c1);
        testingFiles.add(calc_c_h2);
        testingFiles.add(calc_m_h1);
        testingFiles.add(cana_m_h2);
        testingFiles.add(cana_c_h1);
        //testingFiles.add(cana_m_c1);

        return bbc_c_h1 != null && /*bbc_m_c1 != null &&*/ bbc_m_h1 != null
                && /*calc_c_c1 != null && */calc_c_h2 != null && calc_m_h1 != null && cana_m_h1 != null
                && cana_c_h1 != null /*&& cana_m_c1 != null*/;
    }

    ArrayList<LinkedList<SyscallLogRegistry>> learningFiles = new ArrayList();
    public boolean prepareLearningSet() {
        bbc_c_c1 = getSyscalls("bbc-clear-cold-1.log", LogStatus.GOOD, 0);
        //calc_m_c1 = getSyscalls("calc-malware-cold-1.log", LogStatus.MALICIOUS, 0);
        cana_c_c1 = getSyscalls("canary-clear-cold-1.log", LogStatus.GOOD, 0);
        bbc_c_h2 = getSyscalls("bbc-clear-hot-1.log", LogStatus.GOOD, 0);
        bbc_m_h2 = getSyscalls("bbc-malware-hot-2.log", LogStatus.MALICIOUS, 0);
        calc_c_h1 = getSyscalls("calc-clear-hot-1.log", LogStatus.GOOD, 0);
        cana_c_h2 = getSyscalls("canary-clear-hot-1.log", LogStatus.GOOD, 0);
        cana_m_h2 = getSyscalls("canary-malware-hot-2.log", LogStatus.MALICIOUS, 0);

        calc_m_h2 = getSyscalls("calc-malware-hot-2.log", LogStatus.MALICIOUS, 0);

        learningFiles.add(bbc_c_c1);
        //learningFiles.add(calc_m_c1);
        learningFiles.add(cana_c_c1);
        learningFiles.add(bbc_c_h2);
        learningFiles.add(bbc_m_h2);
        learningFiles.add(calc_c_h1);
        learningFiles.add(cana_c_h2);
        //learningFiles.add(cana_m_h2);
        learningFiles.add(calc_m_h2);

        return /*bbc_c_c1 != null && calc_m_c1 != null && cana_c_c1 != null
                && */bbc_c_h2 != null && bbc_m_h2 != null && calc_c_h1 != null && cana_c_h2 != null
                && calc_m_h2  != null && cana_m_h2 != null;
    }

    public LinkedList<SyscallLogRegistry> getSyscalls(String fileName, LogStatus fileStatus, int maxElem) {
        try (Stream<String> syscalls = Files.lines(Paths.get(fileName))) {
            return SysCallLogReader.getSyscallsFromFile(syscalls, fileStatus, maxElem);
        } catch (IOException e) {
            System.out.print("Plik: " + fileName + " " + e.getMessage());
            return null;
        }
    }

    List<String> systCalls;
    public void createSyscallsList(){
        ArrayList<SyscallLogRegistry> allSyscallsRegistry = new ArrayList<>();
        allSyscallsRegistry.addAll(bbc_c_c1);
        allSyscallsRegistry.addAll(bbc_c_h1);
        allSyscallsRegistry.addAll(bbc_c_h2);
        //allSyscallsRegistry.addAll(bbc_m_c1);
        allSyscallsRegistry.addAll(bbc_m_h1);
        allSyscallsRegistry.addAll(bbc_m_h2);
        //allSyscallsRegistry.addAll(calc_c_c1);
        allSyscallsRegistry.addAll(calc_c_h1);
        allSyscallsRegistry.addAll(calc_c_h2);
        //allSyscallsRegistry.addAll(calc_m_c1);
        allSyscallsRegistry.addAll(calc_m_h1);
        allSyscallsRegistry.addAll(calc_m_h2);
        allSyscallsRegistry.addAll(cana_c_c1);
        allSyscallsRegistry.addAll(cana_c_h1);
        allSyscallsRegistry.addAll(cana_c_h2);
        //allSyscallsRegistry.addAll(cana_m_c1);
        allSyscallsRegistry.addAll(cana_m_h1);
        allSyscallsRegistry.addAll(cana_m_h2);

        systCalls = allSyscallsRegistry.stream()
                .map(p -> p.getSyscall())
                .distinct()
                .collect(Collectors.toList());
    }


    int ngram = 2;
    ArrayList<NGramSyscall> allPossibleNgrams = new ArrayList<>();
    public void startNgramsPossibilitiesInit()
    {
        int sysCallsNumber = systCalls.size();
        allPossibleNgrams = new ArrayList<>();

        for(int i=0;i < Math.pow(sysCallsNumber, ngram); i++)
        {
            allPossibleNgrams.add(new NGramSyscall(null, new LinkedList<SyscallLogRegistry>()));
        }

        fillSysCalsPossibilities(allPossibleNgrams, ngram, 0);
    }

    private void fillSysCalsPossibilities(ArrayList<NGramSyscall> allPossibleNgrams, int ngram, int offset) {
        int sysCallsNumber = systCalls.size();
        int numberOfSameSyscalls = (int)Math.pow(sysCallsNumber, ngram-1);
        for(int i=0;i<sysCallsNumber;i++)
        {
            for(int j=0;j<numberOfSameSyscalls;j++)
            {
                allPossibleNgrams.get(offset + i*numberOfSameSyscalls + j).getnGramSyscalls()
                        .add(new SyscallLogRegistry(systCalls.get(i), null));
            }

            if(ngram > 1)
            {
                fillSysCalsPossibilities(allPossibleNgrams, ngram-1, offset+i*numberOfSameSyscalls);
            }
        }
    }

    ArrayList<NGramSyscall> testingNGrams = new ArrayList<>();
    public void createNGramTestingList(){
        //testingNGrams.addAll(createNGramsFromList(okFileLogsTestingSet, nGramSize));
        //testingNGrams.addAll(createNGramsFromList(maliciousFileLogsTestingSet, nGramSize));

        long seed = System.nanoTime();
        Collections.shuffle(testingNGrams, new Random(seed));
    }

    private ArrayList<NGramSyscall> createNGramsFromList(LinkedList<SyscallLogRegistry> sysCalls, int nGramSize)
    {
        ArrayList<NGramSyscall> result = new ArrayList<>();
        LinkedList<SyscallLogRegistry> tmpSysCalls = (LinkedList<SyscallLogRegistry>)sysCalls.clone();
        while(tmpSysCalls.size() >= nGramSize)
        {
            LinkedList<SyscallLogRegistry> nGramSyscalls = new LinkedList<>();
            for(int i=0; i < nGramSize;i++) {
                nGramSyscalls.add(tmpSysCalls.removeFirst());
            }
            result.add(new NGramSyscall(nGramSyscalls.getFirst().getSourceLogFileStatus(), nGramSyscalls));
        }
        return result;
    }

   /* private HashMap<String, Integer> getMappingSet()
    {
        HashMap<String, Integer> mappingSet = new HashMap<>();
        ArrayList<String> everySyscall = new ArrayList<>();
        //everySyscall.addAll(getSyscallList(okFileLogsLearningSet1));
        everySyscall.addAll(getSyscallList(okFileLogsLearningSet2));
        //everySyscall.addAll(getSyscallList(maliciousFileLogsLearningSet1));
        everySyscall.addAll(getSyscallList(maliciousFileLogsLearningSet2));

        ArrayList<String> distinctSyscalls = new ArrayList<>(new HashSet<>(everySyscall));

        int counter = 1;
        for(String syscall : distinctSyscalls) {
            mappingSet.put(syscall, counter++);
        }

        return mappingSet;
    }*/

    private ArrayList<String> getSyscallList(LinkedList<SyscallLogRegistry> registries){
        ArrayList<String> syscallsNames = new ArrayList<>();
        for(SyscallLogRegistry registry : registries) {
            syscallsNames.add(registry.getSyscall());
        }
        return syscallsNames;
    }

    ParagraphVectors vec;
    //HashMap<String, Integer> mapper;
    public void prepareVectorAndLearnWithData() {
        try {
            //mapper = getMappingSet();
            createSyscallsList();
            startNgramsPossibilitiesInit();

            ArrayList<Attribute> fvWekaAttributes = createAttributeHeading();

            Instances isTrainingSet = new Instances("Rel", fvWekaAttributes, 10);
            isTrainingSet.setClassIndex(allPossibleNgrams.size());

            learnTrainingSet(isTrainingSet, fvWekaAttributes);

            LibSVM cModel =  new LibSVM();
            String[] options = new String[18];
            options[0] = "-S"; options[1] = "0";
            options[2] ="-K"; options[3] = "2";
            options[4] = "-G"; options[5] = "0.2";
            options[6] = "-R"; options[7] = "0.0";
            options[8] = "-N"; options[9] = "0.5";
            options[10] = "-M"; options[11] = "40.0";
            options[12] = "-C"; options[13] = "1.0";
            options[14] = "-E"; options[15] = "0.0010";
            options[16] = "-P"; options[17] = "0.1";
            cModel.setOptions(options);
            cModel.buildClassifier(isTrainingSet);

            for(LinkedList<SyscallLogRegistry> testingFile : testingFiles)
            {
                Instance testingInstance = createTestingInstance(testingFile, fvWekaAttributes);
                testingInstance.setDataset(isTrainingSet);
                double[] fDistribution = cModel.distributionForInstance(testingInstance);
                int i = 0;
                System.out.print(testingFile.get(0).getSourceLogFileStatus() + ": ");
                System.out.println("Zgodność:" + fDistribution[0]);
            }
            int i =0;
        } catch (Exception e) {
            //System.out.print(e.getMessage());
            return;
        }
    }

    private Instance createTestingInstance(LinkedList<SyscallLogRegistry> testingFile, ArrayList<Attribute> fvWekaAttributes) {
        List<Double> frequencyVector = getFrequencyVector(testingFile);

        return createTestingSet(frequencyVector, fvWekaAttributes);
    }

    private Instance createTestingSet(List<Double> frequencyVector, ArrayList<Attribute> fvWekaAttributes) {
        Instance iExample = new DenseInstance(allPossibleNgrams.size());
        for (int i = 0; i < allPossibleNgrams.size(); i++) {
            iExample.setValue(fvWekaAttributes.get(i), frequencyVector.get(i));
        }

        return iExample;
    }

    private void learnTrainingSet(Instances isTrainingSet, ArrayList<Attribute> fvWekaAttributes) {
        for(LinkedList<SyscallLogRegistry> learningFile : learningFiles){
            List<Double> frequencyVector = getFrequencyVector(learningFile);
            LogStatus logStatus = learningFile.get(0).getSourceLogFileStatus();
            String className = (logStatus == LogStatus.GOOD ? "clear" : "malicious");
            //className = "clear";
            Instance learingSet = createLearningSet(frequencyVector, fvWekaAttributes, className);
            isTrainingSet.add(learingSet);
        }
    }

    private Instance createLearningSet(List<Double> frequencyVector, ArrayList<Attribute> fvWekaAttributes, String logClass) {
        Instance iExample = new DenseInstance(allPossibleNgrams.size() + 1);
        for (int i = 0; i < allPossibleNgrams.size(); i++) {
            iExample.setValue(fvWekaAttributes.get(i), frequencyVector.get(i));
        }
        iExample.setValue(fvWekaAttributes.get(allPossibleNgrams.size()), logClass);

        return iExample;
    }

    private ArrayList<Attribute> createAttributeHeading() {
        ArrayList<Attribute> fvWekaAttributes = new ArrayList<Attribute>();

        ArrayList<String> fvClassVal = new ArrayList<String>();
        fvClassVal.add("clear");
        fvClassVal.add("malicious");
        Attribute classAttribute = new Attribute("theClass", fvClassVal);

        for (int i = 0; i < allPossibleNgrams.size(); i++) {
            fvWekaAttributes.add(new Attribute("Atrybut " + i));
        }
        fvWekaAttributes.add(classAttribute);
        return fvWekaAttributes;
    }

    private List<Double> getFrequencyVector(LinkedList<SyscallLogRegistry> sysCallsLogs) {
        ArrayList<NGramSyscall> ngramList = createNGramsFromList(sysCallsLogs, ngram);

        ArrayList<NGramSyscall> ngramOccurenceForVector = (ArrayList<NGramSyscall>) allPossibleNgrams.clone();
        fillNgramOccurance(ngramList, ngramOccurenceForVector);
        setFrequency(ngramOccurenceForVector, ngramList.size());

        return createFrequencyVector(ngramOccurenceForVector);
    }

    private List<Double> createFrequencyVector(ArrayList<NGramSyscall> ngramOccurenceForVector) {
        return ngramOccurenceForVector.stream().map(p -> p.frequency).collect(Collectors.toList());
    }

    private void setFrequency(ArrayList<NGramSyscall> ngramOccurenceForVector, double size) {
        for(NGramSyscall syscall : ngramOccurenceForVector)
        {
            syscall.frequency = syscall.numberOfOccurences / size;
        }
    }

    private void fillNgramOccurance(ArrayList<NGramSyscall> ngramList, ArrayList<NGramSyscall> ngramOccurenceForVector) {
        for(NGramSyscall syscall : ngramList)
        {
            increaseOccuranceForNgram(syscall, ngramOccurenceForVector);
        }
    }

    private void increaseOccuranceForNgram(NGramSyscall syscall, ArrayList<NGramSyscall> ngramOccurenceForVector) {
        for(NGramSyscall vectorSyscall : ngramOccurenceForVector)
        {
            if(checkIfSameSysCalls(syscall, vectorSyscall))
            {
                vectorSyscall.numberOfOccurences++;
            }
        }
    }

    private boolean checkIfSameSysCalls(NGramSyscall syscall, NGramSyscall vectorSyscall) {
        if(syscall.getnGramSyscalls().size() != vectorSyscall.getnGramSyscalls().size())
            return false;

        for(int i=0;i<syscall.getnGramSyscalls().size();i++)
        {
            if(!syscall.getnGramSyscalls().get(i).getSyscall().equals(vectorSyscall.getnGramSyscalls().get(i).getSyscall()))
                return false;
        }

        return true;
    }

    public void testVector(){
        createNGramTestingList();

        int goodPredictionCounterForGood = 0;
        int goodPredictionCounterForMalicious = 0;
        int wrongPredictionCounterForGood = 0;
        int wrongPredictionCounterForMalicious = 0;
        for(NGramSyscall nGram : testingNGrams){
            Collection<String> prediction = vec.nearestLabels(nGram.getVector(), 1);
            nGram.setPredictedStatus(prediction.toArray()[0].toString());

            if(nGram.getnGramStatus() == nGram.getPredictedStatus()) {
                if(nGram.getnGramStatus() == LogStatus.GOOD)
                    goodPredictionCounterForGood++;
                else
                    goodPredictionCounterForMalicious++;
            }
            else {
                if(nGram.getnGramStatus() == LogStatus.GOOD)
                    wrongPredictionCounterForGood++;
                else
                    wrongPredictionCounterForMalicious++;
            }
        }
        System.out.print("Done");
    }
}
