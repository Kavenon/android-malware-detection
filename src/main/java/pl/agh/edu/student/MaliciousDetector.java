package pl.agh.edu.student;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.*;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import org.deeplearning4j.models.paragraphvectors.ParagraphVectors;
import org.deeplearning4j.models.word2vec.VocabWord;
import org.deeplearning4j.models.word2vec.wordstore.inmemory.AbstractCache;
import org.deeplearning4j.text.tokenization.tokenizerfactory.DefaultTokenizerFactory;
import org.deeplearning4j.text.tokenization.tokenizerfactory.TokenizerFactory;

public class MaliciousDetector {

    //LinkedList<SyscallLogRegistry> okFileLogsLearningSet1;
    LinkedList<SyscallLogRegistry> okFileLogsLearningSet2;
    //LinkedList<SyscallLogRegistry> maliciousFileLogsLearningSet1;
    LinkedList<SyscallLogRegistry> maliciousFileLogsLearningSet2;
    public boolean prepareLearningSet() {
        //okFileLogsLearningSet1 = getSyscalls("bbc-clear-cold-1.log", LogStatus.GOOD, 20000);
        okFileLogsLearningSet2 = getSyscalls("bbc-clear-hot-1.log", LogStatus.GOOD, 8000);
        //maliciousFileLogsLearningSet1 = getSyscalls("bbc-malware-cold-1.log", LogStatus.MALICIOUS, 20000);
        maliciousFileLogsLearningSet2 = getSyscalls("bbc-malware-hot-1.log", LogStatus.MALICIOUS, 8000);

        //System.out.println("Dobre: " + okFileLogsLearningSet1.size());
        System.out.println("Dobre: " + okFileLogsLearningSet2.size());
        //System.out.println("Złe: " + maliciousFileLogsLearningSet1.size());
        System.out.println("Złe: " + maliciousFileLogsLearningSet2.size());

        return /*okFileLogsLearningSet1 != null && */okFileLogsLearningSet2 != null && /*maliciousFileLogsLearningSet1 != null
                && */maliciousFileLogsLearningSet2 != null;
    }

    public LinkedList<SyscallLogRegistry> getSyscalls(String fileName, LogStatus fileStatus, int maxElem) {
        try (Stream<String> syscalls = Files.lines(Paths.get(fileName))) {
            return SysCallLogReader.getSyscallsFromFile(syscalls, fileStatus, maxElem);
        } catch (IOException e) {
            System.out.print("Plik: " + fileName + " " + e.getMessage());
            return null;
        }
    }

    LinkedList<SyscallLogRegistry> okFileLogsTestingSet;
    LinkedList<SyscallLogRegistry> maliciousFileLogsTestingSet;
    public boolean prepareTestingSet() {
        okFileLogsTestingSet = getSyscalls("bbc-clear-hot-1.log", LogStatus.GOOD, 30000);
        maliciousFileLogsTestingSet = getSyscalls("bbc-malware-hot-2.log", LogStatus.MALICIOUS, 30000);

        return okFileLogsTestingSet != null && maliciousFileLogsTestingSet != null;
    }

    int nGramSize = 10;
    ArrayList<NGramSyscall> learningNGrams = new ArrayList<>();
    public void createNGramLearningList(){
        //learningNGrams.addAll(createNGramsFromList(okFileLogsLearningSet1, nGramSize));
        learningNGrams.addAll(createNGramsFromList(okFileLogsLearningSet2, nGramSize));
        //learningNGrams.addAll(createNGramsFromList(maliciousFileLogsLearningSet1, nGramSize));
        learningNGrams.addAll(createNGramsFromList(maliciousFileLogsLearningSet2, nGramSize));

        long seed = System.nanoTime();
        Collections.shuffle(learningNGrams, new Random(seed));
    }

    ArrayList<NGramSyscall> testingNGrams = new ArrayList<>();
    public void createNGramTestingList(){
        testingNGrams.addAll(createNGramsFromList(okFileLogsTestingSet, nGramSize));
        testingNGrams.addAll(createNGramsFromList(maliciousFileLogsTestingSet, nGramSize));

        long seed = System.nanoTime();
        Collections.shuffle(testingNGrams, new Random(seed));
    }

    private ArrayList<NGramSyscall> createNGramsFromList(LinkedList<SyscallLogRegistry> sysCalls, int nGramSize)
    {
        ArrayList<NGramSyscall> result = new ArrayList<>();
        while(sysCalls.size() >= nGramSize)
        {
            LinkedList<SyscallLogRegistry> nGramSyscalls = new LinkedList<>();
            for(int i=0; i < nGramSize;i++) {
                nGramSyscalls.add(sysCalls.removeFirst());
            }
            result.add(new NGramSyscall(nGramSyscalls.getFirst().getSourceLogFileStatus(), nGramSyscalls));
        }
        return result;
    }

    private HashMap<String, Integer> getMappingSet()
    {
        HashMap<String, Integer> mappingSet = new HashMap<>();
        ArrayList<String> everySyscall = new ArrayList<>();
        //everySyscall.addAll(getSyscallList(okFileLogsLearningSet1));
        everySyscall.addAll(getSyscallList(okFileLogsLearningSet2));
        //everySyscall.addAll(getSyscallList(maliciousFileLogsLearningSet1));
        everySyscall.addAll(getSyscallList(maliciousFileLogsLearningSet2));

        ArrayList<String> distinctSyscalls = new ArrayList<>(new HashSet<>(everySyscall));

        int counter = 1;
        for(String syscall : distinctSyscalls) {
            mappingSet.put(syscall, counter++);
        }

        return mappingSet;
    }

    private ArrayList<String> getSyscallList(LinkedList<SyscallLogRegistry> registries){
        ArrayList<String> syscallsNames = new ArrayList<>();
        for(SyscallLogRegistry registry : registries) {
            syscallsNames.add(registry.getSyscall());
        }
        return syscallsNames;
    }

    ParagraphVectors vec;
    //HashMap<String, Integer> mapper;
    public void prepareVectorAndLearnWithData(){
        //mapper = getMappingSet();
        createNGramLearningList();
        List<String> vectors = learningNGrams.stream().map(item -> item.getVector()).collect(Collectors.toList());
        List<String> labels = learningNGrams.stream().map(item -> item.getnGramStatus().toString()).collect(Collectors.toList());

        AbstractCache<VocabWord> cache = new AbstractCache<>();
        VectorGenerator vectorGenerator = new VectorGenerator();
        ParagraphVectors.Builder builder = new ParagraphVectors.Builder();
        vec = vectorGenerator.generate(labels, vectors, builder, cache);
    }

    public void testVector(){
        createNGramTestingList();

        int goodPredictionCounterForGood = 0;
        int goodPredictionCounterForMalicious = 0;
        int wrongPredictionCounterForGood = 0;
        int wrongPredictionCounterForMalicious = 0;
        for(NGramSyscall nGram : testingNGrams){
            Collection<String> prediction = vec.nearestLabels(nGram.getVector(), 1);
            nGram.setPredictedStatus(prediction.toArray()[0].toString());

            if(nGram.getnGramStatus() == nGram.getPredictedStatus()) {
                if(nGram.getnGramStatus() == LogStatus.GOOD)
                    goodPredictionCounterForGood++;
                else
                    goodPredictionCounterForMalicious++;
            }
            else {
                if(nGram.getnGramStatus() == LogStatus.GOOD)
                    wrongPredictionCounterForGood++;
                else
                    wrongPredictionCounterForMalicious++;
            }
        }
        System.out.print("Done");
    }
}
