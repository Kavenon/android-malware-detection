package pl.agh.edu.student;

import org.deeplearning4j.clustering.cluster.Cluster;
import org.deeplearning4j.clustering.cluster.ClusterSet;
import org.deeplearning4j.clustering.cluster.Point;
import org.deeplearning4j.clustering.kmeans.KMeansClustering;
import org.nd4j.linalg.api.ndarray.INDArray;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;
import java.util.stream.Stream;

public class App {
    public static void main(String[] args) throws IOException {


        try (Stream<String> syscalls = Files.lines(Paths.get("syscalls"))) {
            List<String> avaiableSysCalls = syscalls.collect(Collectors.toList());
            Pattern pattern = Pattern.compile("(\\w*)\\(");


            Map<String, Integer> sysCallOcurrences = new HashMap<>();

            Stream<String> syscallsFromApp = Files.lines(Paths.get("wykop.dump"));
            syscallsFromApp.forEach(line -> {
                Matcher matcher = pattern.matcher(line);
                if(matcher.find()){
                    String sysCall = matcher.group(1);
                    if(sysCallOcurrences.containsKey(sysCall)){
                        sysCallOcurrences.put(sysCall, sysCallOcurrences.get(sysCall) + 1);
                    } else {
                        sysCallOcurrences.put(sysCall, 1);
                    }
                }
            });

            List<Integer> appFeatureVector = new LinkedList<>();
            for (String call : avaiableSysCalls) {
                appFeatureVector.add(sysCallOcurrences.getOrDefault(call, 0));
            }


            // ============================================
            int maxIterationCount = 5;
            int clusterCount = 10;
            String distanceFunction = "cosinesimilarity";
            KMeansClustering kmc = KMeansClustering.setup(clusterCount, maxIterationCount, distanceFunction);

            List<Point> pointsLst = new ArrayList<>();
            pointsLst.add(new Point("myid", "mylabel",  appFeatureVector.stream().mapToDouble(i->i).toArray()));
            pointsLst.add(new Point("myid2", "mylabel",  appFeatureVector.stream().mapToDouble(i->i).toArray()));
            pointsLst.add(new Point("myid3", "mylabel",  appFeatureVector.stream().mapToDouble(i->i).toArray()));
            pointsLst.add(new Point("myid4", "mylabel",  appFeatureVector.stream().mapToDouble(i->i).toArray()));
            pointsLst.add(new Point("myid5", "mylabel",  appFeatureVector.stream().mapToDouble(i->i).toArray()));

            System.out.println(pointsLst);
            ClusterSet cs = kmc.applyTo(pointsLst);

            System.out.println("Finish  Clustering");

            List<Cluster> clsterLst = cs.getClusters();

            System.out.println("\nCluster Centers:");
            for(Cluster c: clsterLst) {
                Point center = c.getCenter();
                System.out.println(center.getId());
            }

//            double[] nesVec = vec.getWordVector("DOC_400");
//            Point newpoint = new Point("myid", "mylabel",  nesVec);
//            PointClassification pc = cs.classifyPoint(newpoint);
//            System.out.println(pc.getCluster().getCenter().getId());

            System.out.println("\nEnd Test");
//            System.out.println(appFeatureVector);

        }

    }
}
